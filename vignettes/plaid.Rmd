---
title: "plaid"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{plaid}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

We developed PLAID (Pathway Level Average Intensity Detection), a
novel, ultrafast and memory optimized gene set scoring
algorithm. PLAID demonstrates accurate gene set scoring and
outperforms all currently available gene set scoring methods in large
single-cell RNA-seq datasets.


# Installing 'plaid'

The most updated version of ‘plaid’ is hosted on GitHub and can be
easily installed using devtools::install_github() function provided by


```{r}
# devtools::install_github('BigOmics/plaid')
```


# Example: Single-cell RNA-seq hallmark scoring

## Preparing data

For this vignette, our package includes a small subset of the the
pmbc3k single-cell dataset of just 50 cells. Please install the Seurat
and SeuratData packages if you want to run this vignette against the
full dataset.

```{r}
library("plaid")
load(system.file("extdata", "pbmc3k-50cells.rda", package = "plaid"),verbose=TRUE)
if(FALSE) {
  library(Seurat)
  library(SeuratData)
  data("pbmc3k.final")
  pbmc3k.final <- Seurat::UpdateSeuratObject(pbmc3k.final)
  X <- pbmc3k.final[['RNA']]@data
  celltype <- pbmc3k.final$seurat_annotations
}
dim(X)
```

Note that X is the normalized expression matrix form the Seurat
object, not the raw counts matrix. We recommend to run Plaid on the
log transformed expression matrix, not the raw counts matrix, as the
average in the logarithmic space is more robust and is in concordance
to calculating the geometric mean.


## Calculating the score

For convenience we have included the 50 Hallmark genesets in our
package. But we encourage you to download larger geneset collections
as Plaid's speed advantage will be more apparent for larger datasets
and large geneset collections.

As Plaid needs the gene sets as sparse matrix, we need first to
convert the gmt list to matrix format.

```{r}
hallmarks <- system.file("extdata", "hallmarks.gmt", package = "plaid")
gmt <- read.gmt(hallmarks)
matG <- gmt2mat(gmt)
dim(matG)
```

Then we can run Plaid on our expression matrix X.


```{r}
gsetX <- plaid(X, matG)
dim(gsetX)
```

## Performing a differential expression test

Once we have the gene sets scores we can use these scores for
statistical analysis. Before
testing, we recommend performing some normalization of the samples,
for example using median normalization. 

```{r}
gsetX <- normalize_medians(gsetX)
```

Then we can compute the differential gene set expression between two
groups using t-test or limma:

```{r}
y <- 1*(celltype == "B")
res <- plaid.test(X, y, matG, gsetX=gsetX, tests=c("one","lm"))
```

The top significant genesets can be shown with

```{r}
head(res[order(res[,"p.meta"]),])
```

We can also show the results with a volcano plot:

```{r}
fc <- res[,"gsetFC"]
pv <- res[,"p.meta"]
plot( fc, -log10(pv), xlab="logFC", ylab="-log10p")
```


# Replicating singscore and scSE

Plaid can be used to compute the singscore (Fouratan et al., 2018)
and Single-Cell Signature Explorer (scSE) score (Pont et al., 2019)
but computation is much faster than the original code.

## Replicating singscore

Computing the singscore requires to compute the ranks of the
expression matrix. We have wrapped this in a single convenience
function:

```{r}
sing <- replaid.sing(X, matG)
```

We have extensively compared `replaid.sing` and results from the
original `singscore` R package.


## Replicating the scSE score

Computing the scSE requires running plaid on the linear (not
logarithmic) score and perform additional normalization by the total
UMI per sample. We have wrapped this in a single convenience function:

```{r}
scse <- replaid.scse(X, matG)
```

We have extensively compared `replaid.scse` and results from the
original scSE (implemented in GO lang).
